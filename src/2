
// USER //
#include "DetectorConstruction.hh"

// GEANT4 //
#include "globals.hh"
#include <G4Transform3D.hh>
#include <vector>
#include <G4TwoVector.hh>
#include <G4GenericTrap.hh>

#include <G4AssemblyVolume.hh>
#include <G4Box.hh>
#include <G4Cons.hh>
#include <G4Element.hh>
#include <G4LogicalVolume.hh>
#include <G4Material.hh>
#include <G4PVPlacement.hh>
#include <G4PVReplica.hh>
#include <G4Polycone.hh>
#include <G4Polyhedra.hh>
#include <G4RotationMatrix.hh>
#include <G4Sphere.hh>
#include <G4SubtractionSolid.hh>
#include <G4ThreeVector.hh>
#include <G4Trd.hh>
#include <G4Tubs.hh>
#include <G4UnionSolid.hh>

#include <G4Colour.hh>
#include <G4ElementTable.hh>
#include <G4MaterialTable.hh>
#include <G4NistManager.hh>
#include <G4Transform3D.hh>
#include <G4VisAttributes.hh>

#include <G4GeometryManager.hh>
#include <G4LogicalVolumeStore.hh>
#include <G4PhysicalVolumeStore.hh>
#include <G4RunManager.hh>
#include <G4SolidStore.hh>
#include <G4UImanager.hh>

#include <G4GDMLParser.hh>
#include <G4Sphere.hh>

#include "G4NistManager.hh"
#include "G4VisAttributes.hh"

#include "G4SystemOfUnits.hh"
#include "GridParameters.hh"
#include <TFile.h>
#include <TTree.h>
const G4double pi = CLHEP::pi;

DetectorConstruction::DetectorConstruction() {
	det_msg = new DetectorMessenger(this);
	for (int i = 0; i < 32; i++)G4cout << Grid::getGridCenter(i) << G4endl;
}
G4LogicalVolume *DetectorConstruction::CreatOneGrid(G4int detIdx, G4int frontRear)
{
	/*
	G4double slitWidth=Grid::get("slitWidth", detIdx);
	G4double pitch, phase, rot, W, H;
	if(frontRear==1){//front
		pitch=Grid::get("frontPicth", detIdx);
		phase=Grid::get("frontPhase",detIdx);
		rot=Grid::get("frontRot", detIdx);
		W=22;
		H=20;
	}
	else{
		pitch=Grid::get("rearPicth", detIdx);
		phase=Grid::get("rearPhase",detIdx);
		rot=Grid::get("rearRot", detIdx);
		W=13;
		H=13;
	}
	if(rot<0){
		rot+=180;
	}
		G4double maxGridLength=sqrt(W*W+H*H);
		int  maxNum=0.5*maxGridLength/pitch;
		G4Box *gridLine= new G4Box("GridLine", 0.5*maxGridLength*mm , 0.5*(pitch-slitWidth) * mm, 0.4* mm/2.);
		for(int i=0;i<=maxNum;i++){
		G4RotationMatrix rotM;
		rotM.rotateZ(rot*deg);
		G4ThreeVector transVector();
		G4SubtractionSolid (const G4String &pName, G4VSolid *pSolidA, G4VSolid *pSolidB, &rotM, const G4ThreeVector &transVector)

		}

		W=W*mm;
		H=H*mm;
		const G4double zPlane[]={-1*mm, 1*mm}; //can be any
		const G4double rInner[]={W/2, H/2, W/2, H/2};
		const G4double rOuter[]={2*W, 2*H, 2*W, 2*H};
		G4Polyhedra *cutGeo=new G4Polyhedra("cutGeo", 0, 2*pi, 4, 2,zPlane, rInner, rOuter); 
		*/

	//phiStart,
	//G4double phiTotal,
	//G4int numSide,
	//G4int numRZ,
	//const G4double zPlane[],
	//const G4double rInner[],
	//const G4double rOuter[] )
}
void DetectorConstruction::CreatGrids(){
	//created by grid_data_creator.py in /home/xiaohl/FHNW/STIX/SolarFlareAnalysis/grids/
	G4String fname="./grid_data/stix_grid_parameters.root";
	G4cout<<"Loading grid parameters from ROOT file: "<<fname<<G4endl;
	TFile f(fname);
	TTree *grids=(TTree*)f.Get("grids");

	//Declaration of leaves types
	Int_t           is_front;
	Int_t           det_idx;
	Float_t         cx, cy, grot, glen, ghw;

	// Set branch addresses.
	grids->SetBranchAddress("is_front",&is_front);
	grids->SetBranchAddress("det_idx",&det_idx);
	grids->SetBranchAddress("cx",&cx);
	grids->SetBranchAddress("cy",&cy);
	grids->SetBranchAddress("grot",&grot);
	grids->SetBranchAddress("glen",&glen);
	grids->SetBranchAddress("ghw",&ghw);

	//     This is the loop skeleton
	//       To read only selected branches, Insert statements like:
	// grids->SetBranchStatus("*",0);  // disable all branches
	// TTreePlayer->SetBranchStatus("branchname",1);  // activate branchname

	Long64_t nentries = grids->GetEntries();

	Long64_t nbytes = 0;
	G4double xc,yc,zc;

	for (int i=0; i<nentries;i++) {
		nbytes += grids->GetEntry(i);
		//if(det_idx!=26)continue;
		G4double maxHalfLen=0.5*glen*mm;
		if(glen==0)continue;
		if(grot!=90 && grot!=270){
			maxHalfLen+= ghw/abs(tan( grot*pi/180.))*mm;
		}

		G4cout<<i<<" :"<<maxHalfLen<<G4endl;
		G4Box *gridGeo= new G4Box("gridGeo", maxHalfLen , ghw * mm, 0.2 * mm);//0.4 cm
		G4ThreeVector pos;
		if(is_front==1){
			pos=Grid::getGridCenter(det_idx,2)+G4ThreeVector(cx*mm-11*mm,cy*mm-10*mm, -1.5*mm);
		}
		else{
			pos=Grid::getGridCenter(det_idx,1)+G4ThreeVector(cx*mm-6.5*mm,cy*mm-6.5*mm, -1.5*mm);
		}
		G4LogicalVolume *GridLog=new G4LogicalVolume(gridGeo, Tungsten, "gridGeo", 0, 0, 0);
		SetVisAttrib(GridLog,		0.4, 				0.4, 			0.9, 				0.9); 
		
		G4cout<<"creating grids:"<<i<<" "<<pos<<G4endl;
		G4RotationMatrix rotM;
		rotM.rotateZ(grot*deg);
		new G4PVPlacement(G4Transform3D(rotM, pos), GridLog, "gridLine", world_logical,
				false, i, false);
	}
	G4cout<<"Grid created"<<G4endl;
	f.Close();
}


G4LogicalVolume *DetectorConstruction::CreatCdTeDetector()
{
	G4Box *CdTeBox = new G4Box("CdTeDet", 5 * mm, 5 * mm, 0.5 * mm);
	G4Box *bigPixelFullGeo =
		new G4Box("bigPixelFull", 2.20 * mm / 2, 4.6 * mm / 2, 0.5 * mm);
	G4Box *bigPixelToCutGeo =
		new G4Box("bigPixelFull", 1.050 * mm / 2, 0.860 * mm / 2, 0.5 * mm);

	// the geometry need to be checked again
	G4ThreeVector transTop(1.050 * mm / 2. - 2.20 * mm / 2.,
			-4.6 * mm / 2. + 0.430 * mm / 2., 0);
	G4ThreeVector transBottom(1.050 * mm / 2. - 2.20 * mm / 2.,
			4.6 * mm / 2. - 0.430 * mm / 2., 0);

	G4RotationMatrix *rot = new G4RotationMatrix(0, 0, 0);
	G4Transform3D *cornerTransTop = new G4Transform3D(*rot, transTop);
	G4Transform3D *cornerTransBottom = new G4Transform3D(*rot, transBottom);
	G4SubtractionSolid *bigPixelTopGeo = new G4SubtractionSolid(
			"topBigPixel", bigPixelFullGeo, bigPixelToCutGeo, *cornerTransTop);
	G4SubtractionSolid *bigPixelBottomGeo = new G4SubtractionSolid(
			"bottomBigPixel", bigPixelFullGeo, bigPixelToCutGeo, *cornerTransBottom);

	G4Box *smallPixelGeo =
		new G4Box("smallPixel", 1.05 * mm / 2, 0.86 * mm / 2, 0.5 * mm);

	G4LogicalVolume *XrayDetLog =
		new G4LogicalVolume(CdTeBox, CdTe, "XrayDetLog", 0, 0, 0);

	G4LogicalVolume *bigPixelTopLog =
		new G4LogicalVolume(bigPixelTopGeo, CdTe, "bigPixelTopLog", 0, 0, 0);
	G4LogicalVolume *bigPixelBottomLog = new G4LogicalVolume(
			bigPixelBottomGeo, CdTe, "bigPixelBottomLog", 0, 0, 0);
	G4LogicalVolume *smallPixelLog =
		new G4LogicalVolume(smallPixelGeo, CdTe, "smallPixelLog", 0, 0, 0);

	G4double bigPixelsX[] = {-3 * 2.2 * mm / 2, -2.20 * mm / 2., 2.2 * mm / 2,
		3 * 2.20 * mm / 2.};
	G4double bigPixelsY[] = {4.6 * mm / 2., 4.6 * mm / 2., 4.6 * mm / 2.,
		4.6 * mm / 2.};
	G4double smallPixelsX[] = {-3.775 * mm, -1.625 * mm, 0.525 * mm, 2.675 * mm};

	G4double bigPixelColor[] = {0.5, 0.6, 0.7, 0.9};
	SetVisAttrib(bigPixelBottomLog, bigPixelColor[0], bigPixelColor[1],
			bigPixelColor[2], bigPixelColor[3]);
	SetVisAttrib(bigPixelTopLog, bigPixelColor[0], bigPixelColor[1],
			bigPixelColor[2], bigPixelColor[3]);
	G4double smallPixelColor[] = {0.9, 0.5, 0.5, 0.9};
	SetVisAttrib(smallPixelLog, smallPixelColor[0], smallPixelColor[1],
			smallPixelColor[2], smallPixelColor[3]);
	G4double detColor[] = {0.5, 0.5, 0.5, 0.9};
	SetVisAttrib(XrayDetLog, detColor[0], detColor[1], detColor[2], detColor[3]);

	G4int copyNb;
	bool checkOverlaps;
	G4String name;
	for (int i = 0; i < 4; i++) {
		G4ThreeVector posBigPixelTop(bigPixelsX[i], bigPixelsY[i], 0);
		copyNb = i;
		name = "pixel";
		new G4PVPlacement(0, posBigPixelTop, bigPixelTopLog, name, XrayDetLog,
				false, copyNb, checkOverlaps);
		copyNb = i + 4;
		name = "pixel";
		G4ThreeVector posBigPixelBottom(bigPixelsX[i], -bigPixelsY[i], 0);
		new G4PVPlacement(0, posBigPixelBottom, bigPixelBottomLog, name, XrayDetLog,
				false, copyNb, checkOverlaps);

		copyNb = i + 8;
		name = "pixel";
		G4ThreeVector posSmallPixel(smallPixelsX[i], 0, 0);
		new G4PVPlacement(0, posSmallPixel, smallPixelLog, name, XrayDetLog, false,
				copyNb, checkOverlaps);
	}

	return XrayDetLog;


}

DetectorConstruction::~DetectorConstruction() { delete det_msg; }

G4VPhysicalVolume *DetectorConstruction::Construct() {
	G4bool overlap_check = true;
	G4NistManager *nist_manager = G4NistManager::Instance();
	Air = nist_manager->FindOrBuildMaterial("G4_AIR");
	Iron = nist_manager->FindOrBuildMaterial("G4_Fe");
	Alum = nist_manager->FindOrBuildMaterial("G4_Al");
	G4Material *Bi = nist_manager->FindOrBuildMaterial("G4_Bi");
	Vacuum = nist_manager->FindOrBuildMaterial("G4_Galactic");
	G4Material *Ta = nist_manager->FindOrBuildMaterial("G4_Ta");
	Tungsten= nist_manager->FindOrBuildMaterial("G4_W");
	G4Material *Bellylium= nist_manager->FindOrBuildMaterial("G4_Be");

	G4Element *elC = nist_manager->FindOrBuildElement("C");
	G4Element *elH = nist_manager->FindOrBuildElement("H");
	G4Element *elAl = nist_manager->FindOrBuildElement("Al");
	G4Element *elO = nist_manager->FindOrBuildElement("O");
	G4Element *elSi = nist_manager->FindOrBuildElement("Si");
	G4Element *elMg = nist_manager->FindOrBuildElement("Mg");
	G4Element *elMn = nist_manager->FindOrBuildElement("Mn");
	G4Element *elFe = nist_manager->FindOrBuildElement("Fe");
	G4Element *elCr = nist_manager->FindOrBuildElement("Cr");
	G4Element *elZn = nist_manager->FindOrBuildElement("Zn");
	G4Element *elTi = nist_manager->FindOrBuildElement("Ti");
	G4Element *elCu = nist_manager->FindOrBuildElement("Cu");
	G4Element *elP = nist_manager->FindOrBuildElement("P");
	G4Element *elS = nist_manager->FindOrBuildElement("S");
	G4Element *elNi = nist_manager->FindOrBuildElement("Ni");
	G4Element *elN = nist_manager->FindOrBuildElement("N");
	G4Element *elCd = nist_manager->FindOrBuildElement("Cd");
	G4Element *elTe = nist_manager->FindOrBuildElement("Te");
	G4Element *elMo = nist_manager->FindOrBuildElement("Mo");
	G4Element *elPb = nist_manager->FindOrBuildElement("Pb");
	G4Element *elRb = nist_manager->FindOrBuildElement("Rb");
	G4Element *elBa = nist_manager->FindOrBuildElement("Ba");
	G4Element *elK = nist_manager->FindOrBuildElement("K");
	G4Element *elAs = nist_manager->FindOrBuildElement("As");
	G4Element *elCs = nist_manager->FindOrBuildElement("Cs");
	G4Element *elNa = nist_manager->FindOrBuildElement("Na");
	G4Element *elW = nist_manager->FindOrBuildElement("W");
	G4Element *elNb = nist_manager->FindOrBuildElement("Nb");
	G4Element *elTa = nist_manager->FindOrBuildElement("Ta");

	// PEEK
	G4double density_peek = 1.31 * g / cm3;
	// http://www.azom.com/article.aspx?ArticleID=7989
	G4int nelements = 3;
	G4int natoms;
	G4Material *PEEK = new G4Material("PEEK", density_peek, nelements = 3);
	PEEK->AddElement(elC, natoms = 1);
	PEEK->AddElement(elH, natoms = 2);
	PEEK->AddElement(elO, natoms = 1);

	G4Material *Scintillator =
		new G4Material("Scintillator", 1.023 * g / cm3, nelements = 2);
	Scintillator->AddElement(elC, 9);
	Scintillator->AddElement(elH, 10);
	/*
	   <D unit="g/cm3" value="1.023"/>
	   <composite n="10" ref="Hydrogen"/>
	   <composite n="9" ref="Carbon"/>
	   */

	   G4Material *MCP= new G4Material("MCP",0.67*3.1*g/cm3, nelements=9);
	   MCP->AddElement(elPb,47.9/100. );
	   MCP->AddElement(elSi,25.8/100. );
	   MCP->AddElement(elO, 18.2/100. );
	   MCP->AddElement(elK, 4.2/100.);
	   MCP->AddElement(elRb, 1.8/100. );
	   MCP->AddElement(elBa,1.3/100. );
	   MCP->AddElement(elAs,0.4/100. );
	   MCP->AddElement(elCs, 0.2/100.);
	   MCP->AddElement(elNa, 0.1/100);

	   G4double ppm=1e-6;
	   G4Material *Tat= new G4Material("Tat",16.654*g/cm3, nelements=13);
	   Tat->AddElement(elC,9*ppm);
	   Tat->AddElement(elO,87*ppm);
	   Tat->AddElement(elN,40*ppm);
	   Tat->AddElement(elH,5*ppm);
	   Tat->AddElement(elFe,3*ppm);
	   Tat->AddElement(elSi,10*ppm);
	   Tat->AddElement(elTi,1*ppm);
	   Tat->AddElement(elNi,3*ppm);
	   Tat->AddElement(elW,19*ppm);
	   Tat->AddElement(elMo,9*ppm);
	   Tat->AddElement(elNb,30*ppm);
	   Tat->AddElement(elCr,3*ppm);
	   Tat->AddElement(elTa,0.99781);

	// Aluminium alloy 6082
	// http://www.aalco.co.uk/datasheets/Aalco-Metals-Ltd_Aluminium-Alloy-6082-T6T651-Plate_148.pdf.ashx
	// average mass fraction
	//
	G4double density = 2.70 * g / cm3;
	G4Material *Al6082 = new G4Material("Al6082", density, nelements = 9);
	Al6082->AddElement(elSi, 1 / 100.);
	Al6082->AddElement(elMg, 0.9 / 100.);
	Al6082->AddElement(elMn, 0.7 / 100.);
	Al6082->AddElement(elFe, 0.25 / 100.);
	Al6082->AddElement(elCr, 0.125 / 100.);
	Al6082->AddElement(elZn, 0.1 / 100.);
	Al6082->AddElement(elTi, 0.05 / 100.);
	Al6082->AddElement(elCu, 0.05 / 100.);
	Al6082->AddElement(elAl, 96.8250 / 100);

	/// Aluminium  alloy 7075 T6
	// http://asm.matweb.com/search/SpecificMaterial.asp?bassnum=MA7075T6

	density = 2.81 * g / cm3;
	G4Material *Al7075 = new G4Material("Al7075", density, nelements = 9);
	Al7075->AddElement(elCr, 0.23 / 100.);
	Al7075->AddElement(elCu, 1.6 / 100.);
	Al7075->AddElement(elFe, 0.25 / 100.);
	Al7075->AddElement(elMg, 2.5 / 100.);
	Al7075->AddElement(elMn, 0.15 / 100.);
	Al7075->AddElement(elSi, 0.2 / 100.);
	Al7075->AddElement(elTi, 0.1 / 100.);
	Al7075->AddElement(elZn, 5.6 / 100.);
	Al7075->AddElement(elAl, 89.37 / 100.);

	// G Alu25
	// http://www.haba.ch/up/ktml/files/produkte/aluminium/de/G-Alu25infode.pdf
	density = 2.66 * g / cm3;
	Alu25 = new G4Material("Alu25", density, nelements = 9);
	Alu25->AddElement(elCr, 0.15 / 100.);
	Alu25->AddElement(elCu, 0.05 / 100.);
	Alu25->AddElement(elFe, 0.2 / 100.);
	Alu25->AddElement(elMg, 4.45 / 100.);
	Alu25->AddElement(elMn, 0.7 / 100.);
	Alu25->AddElement(elSi, 0.2 / 100.);
	Alu25->AddElement(elTi, 0.075 / 100.);
	Alu25->AddElement(elZn, 0.125 / 100.);
	Alu25->AddElement(elAl, 94.05 / 100.);

	/// Vetronit G11; //Expoxy glass fiber
	// http://www.sibel.bg/upl_doc/Vetronit%20G11%20Roving.pdf

	density = 1.9 * g / cm3;

	// 1.4404 Steel14404
	// http://www.lucefin.com/wp-content/files_mf/1.4404a316l70.pdf

	density = 8.0 * g / cm3;
	G4Material *Steel14404 =
		new G4Material("Steel14404", density, nelements = 10);
	Steel14404->AddElement(elC, 0.03 / 100.);
	Steel14404->AddElement(elSi, 1. / 100.);
	Steel14404->AddElement(elMn, 2. / 100.);
	Steel14404->AddElement(elP, 0.045 / 100.);
	Steel14404->AddElement(elS, 0.015 / 100.);
	Steel14404->AddElement(elCr, 17.5 / 100.);
	Steel14404->AddElement(elNi, 12. / 100.);
	Steel14404->AddElement(elN, .11 / 100.);
	Steel14404->AddElement(elMo, 2.25 / 100.);
	Steel14404->AddElement(elFe, 65.05 / 100.);

	// Steel 304
	density = 7.9 * g / cm3;
	G4Material *Steel304 = new G4Material("Steel304", density, nelements = 9);
	Steel304->AddElement(elC, 0.08 / 100.);
	Steel304->AddElement(elSi, 0.375 / 100.);
	Steel304->AddElement(elMn, 1. / 100.);
	Steel304->AddElement(elP, 0.0225 / 100.);
	Steel304->AddElement(elS, 0.015 / 100.);
	Steel304->AddElement(elCr, 19 / 100.);
	Steel304->AddElement(elNi, 12. / 100.);
	Steel304->AddElement(elN, .10 / 100.);
	Steel304->AddElement(elFe, 67.4075 / 100.);
	// Steel 304
	//
	density = 6.2 * g / cm3; // STIX-DS-0017-PSI
	CdTe = new G4Material("CdTe", density, nelements = 2);
	CdTe->AddElement(elCd, natoms = 1);
	CdTe->AddElement(elTe, natoms = 1);

	// Detector Construction
	// Detector Construction

	// world
	world_solid = new G4Box("world_solid", 200 * cm, 200 * cm, 200 * cm);
	world_logical =
		new G4LogicalVolume(world_solid, Vacuum, "world_logical", 0, 0, 0);
	world_physical = new G4PVPlacement(0, G4ThreeVector(), world_logical,
			"world_physical", 0, false, 0);

	G4LogicalVolume *XrayDetLog = CreatCdTeDetector();
	for(int i=0;i<32;i++)
	{
		G4ThreeVector pos=Grid::getGridCenter(i,0);
		G4cout<<i<<", "<<pos<<G4endl;
		new G4PVPlacement(0, pos, XrayDetLog, "Caliste",
				world_logical,false, i, true);
	}

	//X-ray window
	G4Tubs* xRayWindowFront= new G4Tubs("xRayWindowFront",2.5*mm ,90*mm, 1*mm,    0.,2.*M_PI); //3 mm thick in total, front and rear x-ray beryllium 
	G4Tubs* xRayWindowRear= new G4Tubs("xRayWindowRear",12.5*mm ,90*mm, 0.5*mm,    0.,2.*M_PI); //3 mm thick in total, front and rear x-ray beryllium 
	G4LogicalVolume *xRayWindowFrontLog=
		new G4LogicalVolume(xRayWindowFront, Bellylium, "xRayWindowLog", 0, 0, 0);

	G4LogicalVolume *xRayWindowRearLog=
		new G4LogicalVolume(xRayWindowRear, Bellylium, "xRayWindowLog", 0, 0, 0);

	new G4PVPlacement(0, G4ThreeVector(0,0,Grid::gridZ[3]*mm), xRayWindowRearLog, 
				"xRayWindowRearPhys", world_logical, false, 0,true);     

	new G4PVPlacement(0, G4ThreeVector(0,0,Grid::gridZ[4]*mm), xRayWindowFrontLog, 
				"xRayWindowFrontPhys", world_logical, false, 0,true);     

	CreatGrids();
	CreatGridPlates();
	createAttenuator(true);
	world_logical->SetVisAttributes(G4VisAttributes::Invisible);
	G4cout<<"World completed"<<G4endl;
	return world_physical;
}

void DetectorConstruction::CreatGridPlates(){


	
	G4Tubs* gridFrame= new G4Tubs("frontGridPlat",0 ,90*mm, 0.3*mm, 0.,2.*M_PI);
	G4Box *frontGridHolder= new G4Box("gridHolder",11* mm, 10*mm, 0.3*mm);

	G4Box *rearGridHolder= new G4Box("gridHolder",6.5* mm, 6.5*mm, 0.3*mm);

	G4LogicalVolume *frontGridHolderLog =
		new G4LogicalVolume(frontGridHolder, Vacuum, "frontGridHolder", 0, 0, 0);

	G4LogicalVolume *rearGridHolderLog =
		new G4LogicalVolume(rearGridHolder, Vacuum, "backGridHolder", 0, 0, 0);

	G4LogicalVolume *frontGridFrameLog =
		new G4LogicalVolume(gridFrame, Alu25, "frontGridFrameLog", 0, 0, 0);
	G4LogicalVolume *rearGridFrameLog =
		new G4LogicalVolume(gridFrame, Alu25, "rearGridFrameLog", 0, 0, 0);

	G4VPhysicalVolume *frontFrameHolderPhys, *backFrameHolderPhys;
	for(int i=0;i<32;i++)
	{
		G4ThreeVector pos=Grid::getGridCenter(i,0);
		G4cout<<i<<", "<<pos<<G4endl;
	//	new G4PVPlacement(0, pos, XrayDetLog, "Caliste",
	//			world_logical,false, i, true);
		//place detector in the world
		new G4PVPlacement(0, pos, frontGridHolderLog, 
				"frontGridHolderPhys", frontGridFrameLog, false, i,true);     
		new G4PVPlacement(0, pos, rearGridHolderLog, 
				"frontGridHolderPhys", rearGridFrameLog, false, i,true);     
		//place frame holder in the logical volumne
	}

	new G4PVPlacement(0, 
			G4ThreeVector(0,0, Grid::gridZ[2]*mm),
			frontGridFrameLog, "frontGridFrame",
			world_logical,false, 0, true);
	new G4PVPlacement(0,
			G4ThreeVector(0,0, Grid::gridZ[1]*mm),
			rearGridFrameLog, "rearGridFrame",
			world_logical,false, 0, true);

	frontGridFrameLog->SetVisAttributes(G4VisAttributes::Invisible);
	rearGridFrameLog->SetVisAttributes(G4VisAttributes::Invisible);

	//RandomizeColor();



	G4double gridFrameColor[] = {0.4, 0.2, 0.9, 0.9};
	SetVisAttrib(rearGridFrameLog, 
			gridFrameColor[0], 
			gridFrameColor[1], 
			gridFrameColor[2], 
			gridFrameColor[3]); 

	SetVisAttrib(frontGridFrameLog, 
			gridFrameColor[0], 
			gridFrameColor[1], 
			gridFrameColor[2], 
			gridFrameColor[3]); 

}
G4LogicalVolume *DetectorConstruction::constructCFL() {}
G4LogicalVolume *DetectorConstruction::constructBKG() {}

void DetectorConstruction::createAttenuator(bool attenIn=false) {
	G4double halfWidth=12.3*mm/2;
	G4double halfHeight[6]={};
	G4double attPos[6]={};

	G4Box *att= new G4Box("att", maxHalfLen , ghw * mm, 0.2 * mm);//0.4 cm
	G4LogicalVolume *attLog=
		new G4LogicalVolume(att, Alu25, "attLog", 0, 0, 0);
	new G4PVPlacement(0,
			G4ThreeVector(0,0, 3*mm),
			attLog, "attenuator",
			world_logical,false, 0, true);

}

void DetectorConstruction::SetVisAttrib(G4LogicalVolume *log, G4double red,
		G4double green, G4double blue,
		G4double alpha) {
	G4VisAttributes *visAttrib =
		new G4VisAttributes(G4Colour(red, green, blue, alpha));

	visAttrib->SetForceWireframe(true);

	visAttrib->SetForceSolid(true);

	log->SetVisAttributes(visAttrib);
}

void DetectorConstruction::RandomizeColor() {
	G4LogicalVolumeStore *lvs = G4LogicalVolumeStore::GetInstance();
	std::vector<G4LogicalVolume *>::const_iterator lvciter;
	for (lvciter = lvs->begin(); lvciter != lvs->end(); lvciter++) {
		G4double red = G4UniformRand() * 0.7 + 0.15;
		G4double green = G4UniformRand() * 0.7 + 0.15;
		G4double blue = G4UniformRand() * 0.7 + 0.15;
		G4double alpha = 0;
		SetVisAttrib(*lvciter, red, green, blue, alpha);
		// randomize color
		G4String volumeName = (*lvciter)->GetName();
		double mass = (*lvciter)->GetMass() / g;
		G4cout << "~~~ The MASS of " << volumeName << " is " << mass << " g. ~~~"
			<< G4endl;
	}
}
